// Package elasticsearch provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/indigonote/oapi-codegen DO NOT EDIT.
package elasticsearch

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Consulter defines model for consulter.
type Consulter struct {

	// FHIR Encounter
	Consultation *FhirEncounter `json:"consultation,omitempty"`

	// consulter article count
	ConsultationArticleCount *float32 `json:"consultationArticleCount,omitempty"`

	// FHIR Patient
	Consulter *FhirPatient `json:"consulter,omitempty"`
}

// ConsulterCreateRequest defines model for consulter-create-request.
type ConsulterCreateRequest struct {
	Consulters *[]CreateConsulter `json:"consulters,omitempty"`
}

// ConsulterCreateResponse defines model for consulter-create-response.
type ConsulterCreateResponse ConsulterPerPage

// ConsulterPerPage defines model for consulter-per-page.
type ConsulterPerPage struct {

	// consulter list
	Consulters *[]Consulter `json:"consulters,omitempty"`
}

// CreateConsulter defines model for create-consulter.
type CreateConsulter struct {
	Codesystem *FhirCodeSystem `json:"codesystem,omitempty"`

	// FHIR Encounter
	Consultation *FhirEncounter `json:"consultation,omitempty"`

	// FHIR Patient
	Consulter *FhirPatient `json:"consulter,omitempty"`
}

// FhirAddress defines model for fhir-address.
type FhirAddress struct {
	Country    *string `json:"country" validate:"omitempty,max=1048576,fhirString"`
	PostalCode *string `json:"postalCode" validate:"omitempty,max=1048576,fhirString"`
	Text       *string `json:"text" validate:"omitempty,max=1048576,fhirString"`
}

// FhirAttachment defines model for fhir-attachment.
type FhirAttachment struct {

	// Mime type of the content, with charset etc.
	ContentType *string `json:"contentType" validate:"omitempty,fhirCode"`

	// The date that the attachment was first created.
	Creation *string `json:"creation" validate:"omitempty,fhirDateTime"`

	// The actual data of the attachment - a sequence of bytes, base64 encoded.
	Data *string `json:"data" validate:"omitempty,fhirBase64Binary"`

	// The calculated hash of the data using SHA-1. Represented using base64.
	Hash *string `json:"hash" validate:"omitempty,fhirBase64Binary"`

	//
	// The human language of the content. The value can be any valid value according to BCP 47.
	Language *string `json:"language" validate:"omitempty,fhirCode"`

	// The number of bytes of data that make up this attachment (before base64 encoding, if that is done).Number of bytes of content (if url provided)
	Size *int `json:"size,omitempty" validate:"omitempty,fhirUnsignedInt"`

	// A label or set of text to display in place of the data.
	Title *string `json:"title" validate:"omitempty,fhirString,max=1048576"`

	// Uri where the data can be found
	Url *string `json:"url"`
}

// FhirCodeSystem defines model for fhir-code-system.
type FhirCodeSystem struct {
	Concept *[]FhirConcept `json:"concept,omitempty"`
	Content string         `json:"content" validate:"oneof=complete "`
	Id      *string        `json:"id,omitempty" validate:"omitempty,fhirID"`
	Name    *string        `json:"name,omitempty" validate:"omitempty,max=1048576,fhirString"`
	Status  string         `json:"status" validate:"oneof=active "`
	Title   *string        `json:"title,omitempty" validate:"omitempty,max=1048576,fhirString"`
}

// FhirCodeableConcept defines model for fhir-codeable-concept.
type FhirCodeableConcept struct {
	Coding *[]FhirCoding `json:"coding,omitempty"`
}

// FhirCoding defines model for fhir-coding.
type FhirCoding struct {
	Code   *string `json:"code" validate:"omitempty,fhirCode"`
	System *string `json:"system" validate:"omitempty,fhirUri"`
}

// FhirConcept defines model for fhir-concept.
type FhirConcept struct {
	Code    string         `json:"code" validate:"fhirCode"`
	Concept *[]FhirConcept `json:"concept,omitempty"`
	Display *string        `json:"display,omitempty" validate:"omitempty,max=1048576,fhirString"`
}

// FhirContactPoint defines model for fhir-contact-point.
type FhirContactPoint struct {
	System *string `json:"system" validate:"omitempty,oneof=phone email "`
	Value  *string `json:"value" validate:"omitempty,max=1048576,fhirString"`
}

// FhirEncounter defines model for fhir-encounter.
type FhirEncounter struct {

	// FHIR Coding
	Class FhirCoding `json:"class"`
	Id    *string    `json:"id" validate:"omitempty,fhirID"`

	// FHIR Meta
	Meta        *FhirMeta `json:"meta"`
	Participant *[]struct {

		// FHIR Reference
		Individual *FhirReference         `json:"individual"`
		Type       *[]FhirCodeableConcept `json:"type,omitempty"`
	} `json:"participant,omitempty"`

	// planned | arrived | triaged | in-progress | onleave | finished | cancelled | entered-in-error | unknown
	Status string `json:"status" validate:"oneof=planned arrived triaged in-progress onleave finished cancelled entered-in-error unknown "`
}

// FhirExtension defines model for fhir-extension.
type FhirExtension struct {
	Url             string `json:"url" validate:"fhirUri"`
	ValueAttachment *struct {
		// Embedded struct due to allOf(#/components/schemas/fhir-attachment)
		FhirAttachment
	} `json:"valueAttachment" validate:"omitempty,fhirValueX"`
	ValueCode      *string `json:"valueCode" validate:"omitempty,fhirCode,fhirValueX"`
	ValueInstant   *string `json:"valueInstant" validate:"omitempty,fhirInstant,fhirValueX"`
	ValueReference *struct {
		// Embedded struct due to allOf(#/components/schemas/fhir-reference)
		FhirReference
	} `json:"valueReference" validate:"omitempty,fhirValueX"`
	ValueString *string `json:"valueString" validate:"omitempty,max=1048576,fhirString,fhirValueX"`
}

// FhirHumanName defines model for fhir-human-name.
type FhirHumanName struct {
	Extension *[]FhirExtension `json:"extension,omitempty"`
	Text      *string          `json:"text" validate:"omitempty,max=1048576,fhirString"`
	Use       *string          `json:"use" validate:"omitempty,oneof=usual official "`
}

// FhirIdentifier defines model for fhir-identifier.
type FhirIdentifier struct {
	System *string `json:"system" validate:"omitempty,fhirUri"`
	Use    *string `json:"use" validate:"omitempty,oneof=usual official "`
	Value  *string `json:"value" validate:"omitempty,max=1048576,fhirString"`
}

// FhirMeta defines model for fhir-meta.
type FhirMeta struct {
	Extension   *[]FhirExtension `json:"extension,omitempty"`
	LastUpdated *string          `json:"lastUpdated" validate:"omitempty,fhirInstant"`
	VersionId   *string          `json:"versionId,omitempty" validate:"omitempty,fhirID"`
}

// FhirPatient defines model for fhir-patient.
type FhirPatient struct {

	// active status of patient
	Active *bool `json:"active"`

	// list address of patient
	Address *[]FhirAddress `json:"address,omitempty"`

	// birth date of patient
	BirthDate *string `json:"birthDate" validate:"omitempty,fhirDate"`

	// Additional contents of patient
	Extension *[]FhirExtension `json:"extension,omitempty"`

	// gender of patient: male | female | other | unknown
	Gender *string `json:"gender" validate:"omitempty,oneof=male female other unknown "`

	// list general practitioner
	GeneralPractitioner *[]FhirReference `json:"generalPractitioner,omitempty"`

	// id of patient
	Id *string `json:"id" validate:"omitempty,fhirID"`

	// list identifier of patient
	Identifier *[]FhirIdentifier `json:"identifier,omitempty"`

	// Link to another patient resource that concerns the same actual person
	Link *[]struct {

		// FHIR Reference
		Other *FhirReference `json:"other"`

		// type reference: replaced-by | replaces
		Type string `json:"type" validate:"oneof=replaced-by replaces "`
	} `json:"link,omitempty"`

	// FHIR Meta
	Meta *FhirMeta `json:"meta"`

	// name of patient
	Name *[]FhirHumanName `json:"name,omitempty"`

	// telecom of patient
	Telecom *[]FhirContactPoint `json:"telecom,omitempty"`
}

// FhirReference defines model for fhir-reference.
type FhirReference struct {
	Reference *string `json:"reference" validate:"omitempty,max=1048576,fhirString"`
	Type      *string `json:"type" validate:"omitempty,fhirUri"`
}

// PostConsultersJSONBody defines parameters for PostConsulters.
type PostConsultersJSONBody ConsulterCreateRequest

// PostConsultersRequestBody defines body for PostConsulters for application/json ContentType.
type PostConsultersJSONRequestBody PostConsultersJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A callback for modifying requests which are generated before sending over
	// the network.
	RequestEditor RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditor = fn
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostConsulters request  with any body
	PostConsultersWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	PostConsulters(ctx context.Context, body PostConsultersJSONRequestBody) (*http.Response, error)
}

func (c *Client) PostConsultersWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPostConsultersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostConsulters(ctx context.Context, body PostConsultersJSONRequestBody) (*http.Response, error) {
	req, err := NewPostConsultersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

// NewPostConsultersRequest calls the generic PostConsulters builder with application/json body
func NewPostConsultersRequest(server string, body PostConsultersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostConsultersRequestWithBody(server, "application/json", bodyReader)
}

// NewPostConsultersRequestWithBody generates requests for PostConsulters with any type of body
func NewPostConsultersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/consulters")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostConsulters request  with any body
	PostConsultersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*PostConsultersResponse, error)

	PostConsultersWithResponse(ctx context.Context, body PostConsultersJSONRequestBody) (*PostConsultersResponse, error)
}

type PostConsultersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsulterCreateResponse
}

// Status returns HTTPResponse.Status
func (r PostConsultersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostConsultersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostConsultersWithBodyWithResponse request with arbitrary body returning *PostConsultersResponse
func (c *ClientWithResponses) PostConsultersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*PostConsultersResponse, error) {
	rsp, err := c.PostConsultersWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostConsultersResponse(rsp)
}

func (c *ClientWithResponses) PostConsultersWithResponse(ctx context.Context, body PostConsultersJSONRequestBody) (*PostConsultersResponse, error) {
	rsp, err := c.PostConsulters(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParsePostConsultersResponse(rsp)
}

// ParsePostConsultersResponse parses an HTTP response from a PostConsultersWithResponse call
func ParsePostConsultersResponse(rsp *http.Response) (*PostConsultersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostConsultersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsulterCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Post Consulters
	// (POST /consulters)
	PostConsulters(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostConsulters converts echo context to params.
func (w *ServerInterfaceWrapper) PostConsulters(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostConsulters(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST("/consulters", wrapper.PostConsulters)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"xdOWL9gBXV+v/x8AAP//ZKAAMcp6AAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
