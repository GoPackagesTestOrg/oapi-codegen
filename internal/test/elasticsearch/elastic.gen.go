// Package elasticsearch provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/indigonote/oapi-codegen DO NOT EDIT.
package elasticsearch

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Consulter defines model for consulter.
type Consulter struct {

	// FHIR Encounter
	Consultation *FhirEncounter `json:"consultation,omitempty"`

	// consulter article count
	ConsultationArticleCount *float32 `json:"consultationArticleCount,omitempty"`

	// FHIR Patient
	Consulter *FhirPatient `json:"consulter,omitempty"`
}

// ConsulterCreateRequest defines model for consulter-create-request.
type ConsulterCreateRequest struct {
	Consulters *[]CreateConsulter `json:"consulters,omitempty"`
}

// ConsulterCreateResponse defines model for consulter-create-response.
type ConsulterCreateResponse ConsulterPerPage

// ConsulterPerPage defines model for consulter-per-page.
type ConsulterPerPage struct {

	// consulter list
	Consulters *[]Consulter `json:"consulters,omitempty"`
}

// CreateConsulter defines model for create-consulter.
type CreateConsulter struct {
	Codesystem *FhirCodeSystem `json:"codesystem,omitempty"`

	// FHIR Encounter
	Consultation *FhirEncounter `json:"consultation,omitempty"`

	// FHIR Patient
	Consulter *FhirPatient `json:"consulter,omitempty"`
}

// FhirAddress defines model for fhir-address.
type FhirAddress struct {
	Country    *string `json:"country" validate:"omitempty,fhirString,max=1048576"`
	PostalCode *string `json:"postalCode" validate:"omitempty,max=1048576,fhirString"`
	Text       *string `json:"text" validate:"omitempty,max=1048576,fhirString"`
}

// FhirAttachment defines model for fhir-attachment.
type FhirAttachment struct {

	// Mime type of the content, with charset etc.
	ContentType *string `json:"contentType" validate:"omitempty,fhirCode"`

	// The date that the attachment was first created.
	Creation *string `json:"creation" validate:"omitempty,fhirDateTime"`

	// The actual data of the attachment - a sequence of bytes, base64 encoded.
	Data *string `json:"data" validate:"omitempty,fhirBase64Binary"`

	// The calculated hash of the data using SHA-1. Represented using base64.
	Hash *string `json:"hash" validate:"omitempty,fhirBase64Binary"`

	//
	// The human language of the content. The value can be any valid value according to BCP 47.
	Language *string `json:"language" validate:"omitempty,fhirCode"`

	// The number of bytes of data that make up this attachment (before base64 encoding, if that is done).Number of bytes of content (if url provided)
	Size *int `json:"size,omitempty" validate:"omitempty,fhirUnsignedInt"`

	// A label or set of text to display in place of the data.
	Title *string `json:"title" validate:"omitempty,max=1048576,fhirString"`

	// Uri where the data can be found
	Url *string `json:"url"`
}

// FhirCodeSystem defines model for fhir-code-system.
type FhirCodeSystem struct {
	Concept *[]FhirConcept `json:"concept,omitempty"`
	Content string         `json:"content" validate:"oneof=complete "`
	Id      *string        `json:"id,omitempty" validate:"omitempty,fhirID"`
	Name    *string        `json:"name,omitempty" validate:"omitempty,max=1048576,fhirString"`
	Status  string         `json:"status" validate:"oneof=active "`
	Title   *string        `json:"title,omitempty" validate:"omitempty,max=1048576,fhirString"`
}

// FhirCodeableConcept defines model for fhir-codeable-concept.
type FhirCodeableConcept struct {
	Coding *[]FhirCoding `json:"coding,omitempty"`
}

// FhirCoding defines model for fhir-coding.
type FhirCoding struct {
	Code   *string `json:"code" validate:"omitempty,fhirCode"`
	System *string `json:"system" validate:"omitempty,fhirUri"`
}

// FhirConcept defines model for fhir-concept.
type FhirConcept struct {
	Code    string         `json:"code" validate:"fhirCode"`
	Concept *[]FhirConcept `json:"concept,omitempty"`
	Display *string        `json:"display,omitempty" validate:"omitempty,max=1048576,fhirString"`
}

// FhirContactPoint defines model for fhir-contact-point.
type FhirContactPoint struct {
	System *string `json:"system" validate:"omitempty,oneof=phone email "`
	Value  *string `json:"value" validate:"omitempty,max=1048576,fhirString"`
}

// FhirEncounter defines model for fhir-encounter.
type FhirEncounter struct {

	// FHIR Coding
	Class FhirCoding `json:"class"`
	Id    *string    `json:"id" validate:"omitempty,fhirID"`

	// FHIR Meta
	Meta        *FhirMeta `json:"meta"`
	Participant *[]struct {

		// FHIR Reference
		Individual *FhirReference         `json:"individual"`
		Type       *[]FhirCodeableConcept `json:"type,omitempty"`
	} `json:"participant,omitempty"`

	// planned | arrived | triaged | in-progress | onleave | finished | cancelled | entered-in-error | unknown
	Status string `json:"status" validate:"oneof=planned arrived triaged in-progress onleave finished cancelled entered-in-error unknown "`
}

// FhirExtension defines model for fhir-extension.
type FhirExtension struct {
	Url             string `json:"url" validate:"fhirUri"`
	ValueAttachment *struct {
		// Embedded struct due to allOf(#/components/schemas/fhir-attachment)
		FhirAttachment
	} `json:"valueAttachment" validate:"omitempty,fhirValueX"`
	ValueCode      *string `json:"valueCode" validate:"omitempty,fhirCode,fhirValueX"`
	ValueInstant   *string `json:"valueInstant" validate:"omitempty,fhirInstant,fhirValueX"`
	ValueReference *struct {
		// Embedded struct due to allOf(#/components/schemas/fhir-reference)
		FhirReference
	} `json:"valueReference" validate:"omitempty,fhirValueX"`
	ValueString *string `json:"valueString" validate:"omitempty,max=1048576,fhirString,fhirValueX"`
}

// FhirHumanName defines model for fhir-human-name.
type FhirHumanName struct {
	Extension *[]FhirExtension `json:"extension,omitempty"`
	Text      *string          `json:"text" validate:"omitempty,max=1048576,fhirString"`
	Use       *string          `json:"use" validate:"omitempty,oneof=usual official "`
}

// FhirIdentifier defines model for fhir-identifier.
type FhirIdentifier struct {
	System *string `json:"system" validate:"omitempty,fhirUri"`
	Use    *string `json:"use" validate:"omitempty,oneof=usual official "`
	Value  *string `json:"value" validate:"omitempty,fhirString,max=1048576"`
}

// FhirMeta defines model for fhir-meta.
type FhirMeta struct {
	Extension   *[]FhirExtension `json:"extension,omitempty"`
	LastUpdated *string          `json:"lastUpdated" validate:"omitempty,fhirInstant"`
	VersionId   *string          `json:"versionId,omitempty" validate:"omitempty,fhirID"`
}

// FhirPatient defines model for fhir-patient.
type FhirPatient struct {

	// active status of patient
	Active *bool `json:"active"`

	// list address of patient
	Address *[]FhirAddress `json:"address,omitempty"`

	// birth date of patient
	BirthDate *string `json:"birthDate" validate:"omitempty,fhirDate"`

	// Additional contents of patient
	Extension *[]FhirExtension `json:"extension,omitempty"`

	// gender of patient: male | female | other | unknown
	Gender *string `json:"gender" validate:"omitempty,oneof=male female other unknown "`

	// list general practitioner
	GeneralPractitioner *[]FhirReference `json:"generalPractitioner,omitempty"`

	// id of patient
	Id *string `json:"id" validate:"omitempty,fhirID"`

	// list identifier of patient
	Identifier *[]FhirIdentifier `json:"identifier,omitempty"`

	// Link to another patient resource that concerns the same actual person
	Link *[]struct {

		// FHIR Reference
		Other *FhirReference `json:"other"`

		// type reference: replaced-by | replaces
		Type string `json:"type" validate:"oneof=replaced-by replaces "`
	} `json:"link,omitempty"`

	// FHIR Meta
	Meta *FhirMeta `json:"meta"`

	// name of patient
	Name *[]FhirHumanName `json:"name,omitempty"`

	// telecom of patient
	Telecom *[]FhirContactPoint `json:"telecom,omitempty"`
}

// FhirReference defines model for fhir-reference.
type FhirReference struct {
	Reference *string `json:"reference" validate:"omitempty,max=1048576,fhirString"`
	Type      *string `json:"type" validate:"omitempty,fhirUri"`
}

// PostConsultersJSONBody defines parameters for PostConsulters.
type PostConsultersJSONBody ConsulterCreateRequest

// PostConsultersRequestBody defines body for PostConsulters for application/json ContentType.
type PostConsultersJSONRequestBody PostConsultersJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A callback for modifying requests which are generated before sending over
	// the network.
	RequestEditor RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditor = fn
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostConsulters request  with any body
	PostConsultersWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	PostConsulters(ctx context.Context, body PostConsultersJSONRequestBody) (*http.Response, error)
}

func (c *Client) PostConsultersWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPostConsultersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostConsulters(ctx context.Context, body PostConsultersJSONRequestBody) (*http.Response, error) {
	req, err := NewPostConsultersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

// NewPostConsultersRequest calls the generic PostConsulters builder with application/json body
func NewPostConsultersRequest(server string, body PostConsultersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostConsultersRequestWithBody(server, "application/json", bodyReader)
}

// NewPostConsultersRequestWithBody generates requests for PostConsulters with any type of body
func NewPostConsultersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/consulters")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostConsulters request  with any body
	PostConsultersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*PostConsultersResponse, error)

	PostConsultersWithResponse(ctx context.Context, body PostConsultersJSONRequestBody) (*PostConsultersResponse, error)
}

type PostConsultersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsulterCreateResponse
}

// Status returns HTTPResponse.Status
func (r PostConsultersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostConsultersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostConsultersWithBodyWithResponse request with arbitrary body returning *PostConsultersResponse
func (c *ClientWithResponses) PostConsultersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*PostConsultersResponse, error) {
	rsp, err := c.PostConsultersWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostConsultersResponse(rsp)
}

func (c *ClientWithResponses) PostConsultersWithResponse(ctx context.Context, body PostConsultersJSONRequestBody) (*PostConsultersResponse, error) {
	rsp, err := c.PostConsulters(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParsePostConsultersResponse(rsp)
}

// ParsePostConsultersResponse parses an HTTP response from a PostConsultersWithResponse call
func ParsePostConsultersResponse(rsp *http.Response) (*PostConsultersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostConsultersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsulterCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Post Consulters
	// (POST /consulters)
	PostConsulters(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostConsulters converts echo context to params.
func (w *ServerInterfaceWrapper) PostConsulters(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostConsulters(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST("/consulters", wrapper.PostConsulters)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
